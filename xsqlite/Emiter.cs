using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace xsqlite {
    public static class Emiter {
        public static void Emit(this DataBase db, string author, string predef, string className, string defFile, string implFile) {
            var def=generate_def(author, predef, className, db);
            var impl=generate_impl(author, className, db);

            File.WriteAllText(defFile, def);
            File.WriteAllText(implFile, impl);
        }

        private static string generate_def(string author, string predef, string className, DataBase db) {
            var sb=new StringBuilder();
            def_head(sb, author, predef, className);
            sql_tablecreate_def(sb, db);
            sql_tablequery_def(sb, db);

            class_head_def(sb, className, db);
            sb.Push();
            sb.Line("public:", true);
            constructor_def(sb, className, db);
            destructor_def(sb, className, db);
            open_def(sb, className, db);
            close_def(sb, className, db);
            transaction_def(sb, className);

            sb.Line("public:", true);
            foreach (var tableInfo in db.Tables) {
                var tag=tableInfo.Name;
                var fields=tableInfo.Fields;
                insert_def(sb, className, tag, fields);
                remove_def(sb, className, tag, fields);
                find_by_primarykey_def(sb, className, tag, fields);
                beginfind_def(sb, className, tag, fields);
                movenext_def(sb, className, tag, fields);
                endfind_def(sb, className, tag, fields);
                update_def(sb, className, tag, fields);
                sb.Line();
            }
            member_def(sb, className, db);
            sb.Pop();

            class_tail_def(sb, className, db);

            def_tail(sb, predef, className);

            return sb.ToString();
        }

        private static string generate_impl(string author, string className, DataBase db) {
            var sb=new StringBuilder();
            impl_head(sb, author, className);
            sql_tablecreate_impl(sb, db);
            sql_tablequery_impl(sb, db);
            constructor_impl(sb, className, db);
            destructor_impl(sb, className, db);
            open_impl(sb, className, db);
            close_impl(sb, className, db);
            transaction_impl(sb, className);
            foreach (var tableInfo in db.Tables) {
                var tag=tableInfo.Name;
                var fields=tableInfo.Fields;
                insert_impl(sb, className, tag, fields);
                remove_impl(sb, className, tag, fields);
                find_by_primarykey_impl(sb, className, tag, fields);
                beginfind_impl(sb, className, tag, fields);
                movenext_impl(sb, className, tag, fields);
                endfind_impl(sb, className, tag, fields);
                update_impl(sb, className, tag, fields);
            }
            impl_tail(sb, className);

            return sb.ToString();
        }

        private static void def_head(StringBuilder sb, string author, string predef, string className) {
            sb.Line(@"/************************************************************************/");
            sb.Line(@"// AutoGenerate Sqlite ORM Code, DO NOT MODIFY                            ");
            sb.Line(@"// Generated By sqliteorm.linq                                            ");
            sb.FormatLine(@"// Author: {0}", author);
            sb.FormatLine(@"// Date  : {0}", DateTime.Now);
            sb.Line(@"/************************************************************************/");
            sb.FormatLine(@"#ifndef __{0}_{1}_H__", predef.ToUpper(), className.ToUpper());
            sb.FormatLine(@"#define __{0}_{1}_H__", predef.ToUpper(), className.ToUpper());
            sb.Line();
            sb.Line("#include <stdint.h> // C99");
            sb.Line("#include \"../sqlite/sqlite3.h\"");
            sb.Line();
            sb.Line("#define RESULT_ALREADY_EXISTS 200");
            sb.Line("#define VERIFY_RET(s,op,ret) if(ret!=SQLITE_OK){printf(\"%s %s result=%d\",s,op,ret);return SQLITE_ERROR;}");
            sb.Line("#define VERIFY_RET_BY(s,op,exp,ret) if(!(exp)){printf(\"%s %s result=%d\",s,op,ret);return SQLITE_ERROR;}");
            sb.Line("#define TABLE(table) \"CREATE TABLE IF NOT EXISTS \" table");
            sb.Line();
        }

        private static void def_tail(StringBuilder sb, string predef, string className) {
            sb.FormatLine("#endif // __{0}_{1}_H__", predef.ToUpper(), className.ToUpper());
        }

        private static void impl_head(StringBuilder sb, string author, string className) {
            sb.Line(@"/************************************************************************/");
            sb.Line(@"// Generate Sqlite ORM Code, DO NOT MODIFY                                ");
            sb.FormatLine(@"// Author: {0}", author);
            sb.FormatLine(@"// Date  : {0}", DateTime.Now);
            sb.Line(@"/************************************************************************/");
            sb.FormatLine("#include \"./{0}.h\"", className);
            sb.Line();
            sb.Line();
        }

        private static void impl_tail(StringBuilder sb, string className) {

        }

        private static void sql_tablecreate_def(StringBuilder sb, DataBase db) {
            sb.Line("typedef enum tagSQLCreateTableId {");

            sb.Push();
            int index=0;
            foreach (var table in db.Tables) {
                sb.FormatLine("SQL_Create{0} = {1},", table.Name, index);
                index++;
            }
            sb.FormatLine("SQL_CreateTable_Size = {0}", index);
            sb.Pop();

            sb.Line("}SQLCreateTableId;");
            sb.Line();
            sb.Line("typedef struct tagSQLCreateTable {");

            sb.Push();
            sb.Line("SQLCreateTableId id;");
            sb.Line("std::string sql;");
            sb.Pop();

            sb.Line("}SQLCreateTable;");
            sb.Line();
        }

        private static void sql_tablecreate_impl(StringBuilder sb, DataBase db) {
            sb.Line("static SQLCreateTable TaskCreateTableStatements[] = {");
            sb.Push();
            foreach (var table in db.Tables) {
                var sql=sql_create(table.Name, table.Fields);
                sb.FormatLine("{{SQL_Create{0},{1}}},", table.Name, sql);
            }
            sb.Pop();
            sb.Line("};");
            sb.Line();
        }

        private static string get_label_name(string tag, string label) {
            return tag+"_"+label;
        }

        private static void sql_tablequery_def(StringBuilder sb, DataBase db) {
            sb.Line("typedef enum tagSQLQueryStatementId {");

            sb.Push();
            int index=0;
            foreach (var table in db.Tables) {
                sb.FormatLine("SQL_Insert{0} = {1},", table.Name, index);
                index++;

                sb.FormatLine("SQL_Remove{0}ByPrimaryKey = {1},", table.Name, index);
                index++;

                var removeGroup=table.Fields.SelectMany(f => f.remove_labels).Distinct();
                foreach (var removeLabel in removeGroup) {
                    var removeName=get_label_name(table.Name, removeLabel);
                    sb.FormatLine("SQL_Remove{0} = {1},", removeName, index);
                    index++;
                }

                sb.FormatLine("SQL_Find{0}ByPrimaryKey = {1},", table.Name, index);
                index++;

                sb.FormatLine("SQL_FindAll{0}s = {1},", table.Name, index);
                index++;

                var searchKeys=table.Fields.SelectMany(f => f.search_keys).Distinct();
                foreach (var searchLabel in searchKeys) {
                    var searchName=get_label_name(table.Name, searchLabel.Replace("k", ""));
                    sb.FormatLine("SQL_Find{0} = {1},", searchName, index);
                    index++;
                }

                var updateKeyGroup=table.Fields.SelectMany(f => f.update_keys).Distinct();
                foreach (var updateKey in updateKeyGroup) {
                    var updateName=get_label_name(table.Name, updateKey.Replace("k", ""));
                    sb.FormatLine("SQL_Update{0} = {1},", updateName, index);
                    index++;
                }



                sb.Line();
            }

            // 添加备用语句
            foreach (var freeQuery in db.FreeQuerys){
                sb.FormatLine("{0} = {1},",freeQuery.Name, index);
                index++;     
            }
            


            sb.FormatLine("SQL_QueryStatement_Size = {0}", index);
            sb.Pop();

            sb.Line("}SQLQueryStatementId;");
            sb.Line();
            sb.Line("typedef struct tagSQLQueryStatement {");

            sb.Push();
            sb.Line("SQLQueryStatementId id;");
            sb.Line("std::string sql;");
            sb.Pop();

            sb.Line("}SQLQueryStatement;");
            sb.Line();
        }

        private static void sql_tablequery_impl(StringBuilder sb, DataBase db) {
            sb.Line("static SQLQueryStatement TaskQueryStatements[] = {");
            sb.Push();
            int index=0;
            foreach (var table in db.Tables) {
                var sql=sql_insert(table.Name, table.Fields);
                sb.FormatLine("{{SQL_Insert{0},\"{1}\"}},", table.Name, sql);

                sql=sql_remove_by_primarykey(table.Name, table.Fields);
                sb.FormatLine("{{SQL_Remove{0}ByPrimaryKey,\"{1}\"}},", table.Name, sql);

                var removeGroup=table.Fields.SelectMany(f => f.remove_labels).Distinct();
                foreach (var removeLabel in removeGroup) {
                    sql=sql_remove_by_label(table.Name, table.Fields, removeLabel);
                    var removeName=get_label_name(table.Name, removeLabel);
                    sb.FormatLine("{{SQL_Remove{0},\"{1}\"}},", removeName, sql);
                }

                sql=sql_find_by_primarykey(table.Name, table.Fields);
                sb.FormatLine("{{SQL_Find{0}ByPrimaryKey,\"{1}\"}},", table.Name, sql);

                sql=sql_find_by_all(table.Name, table.Fields);
                sb.FormatLine("{{SQL_FindAll{0}s,\"{1}\"}},", table.Name, sql);

                var searchKeys=table.Fields.SelectMany(f => f.search_keys).Distinct();
                foreach (var searchKey in searchKeys) {
                    sql=sql_find_by_ky(table.Name, table.Fields, searchKey);
                    var searchName=get_label_name(table.Name, searchKey.Replace("k", ""));
                    sb.FormatLine("{{SQL_Find{0},\"{1}\"}},", searchName, sql);
                }

                var updateKeyGroup=table.Fields.SelectMany(f => f.update_keys).Distinct();
                foreach (var updateKey in updateKeyGroup) {
                    sql=sql_update_by_key(table.Name, table.Fields, updateKey);
                    var updateName=get_label_name(table.Name, updateKey.Replace("k", ""));
                    sb.FormatLine("{{SQL_Update{0},\"{1}\"}},", updateName, sql);
                }

                index++;
                if (index<db.Tables.Count()) {
                    sb.Line();
                }
            }

            // 添加备用语句
            foreach (var freeQuery in db.FreeQuerys){
                sb.FormatLine("{{{0},{1}}},", freeQuery.Name,freeQuery.Statement);
                index++;    
            }

            sb.Pop();
            sb.Line("};");
            sb.Line();
        }

        private static void class_head_def(StringBuilder sb, string className, DataBase db) {
            sb.FormatLine("class {0}", className);
            sb.Line("{");
        }

        private static void class_tail_def(StringBuilder sb, string className, DataBase db) {
            sb.Line("public:", true);
            sb.Push();
            sb.Line("sqlite3_stmt* GetSqliteStatement(SQLQueryStatementId id)");
            sb.PushLine("{");
            sb.Line("return m_sqls[id];");
            sb.PopLine("}");
            sb.Pop();
            sb.Line("};");
        }

        private static void member_def(StringBuilder sb, string className, DataBase db) {
            sb.Line("private:", true);
            sb.Line("std::string m_dbPath;");
            sb.Line("sqlite3 * m_pSqlite;");
            sb.Line("sqlite3_stmt * m_sqls[SQL_QueryStatement_Size];");
            sb.Line("int m_openReferenceCount;");
            sb.Line();

            sb.Line("private:", true);
            sb.FormatLine("{0}(const {0}& that);", className);
            sb.FormatLine("{0}& operator=(const {0}& that);", className);
        }

        private static void constructor_def(StringBuilder sb, string className, DataBase db) {
            sb.FormatLine("{0}(const std::string& dbPath);", className);
        }

        private static void constructor_impl(StringBuilder sb, string className, DataBase db) {
            sb.FormatLine("{0}::{0}(const std::string& dbPath)", className);

            sb.Push();
            sb.Line(": m_openReferenceCount(0)");
            sb.Line(", m_pSqlite(NULL)");
            sb.Line(", m_dbPath(dbPath)");
            sb.Pop();

            sb.Line("{").Push();

            sb.Line("for (size_t i = 0; i < sizeof(m_sqls) / sizeof(m_sqls[0]); i++) {");
            sb.Push().Line("m_sqls[i] = NULL;").Pop();
            sb.Line("}");

            sb.Pop().Line("}");
        }

        private static void destructor_def(StringBuilder sb, string className, DataBase db) {
            sb.FormatLine("~{0}();", className);
        }

        private static void destructor_impl(StringBuilder sb, string className, DataBase db) {
            sb.FormatLine("{0}::~{0}()", className);

            sb.Line("{").Push();
            sb.Line("assert(m_pSqlite==NULL);");
            sb.Pop().Line("}");
        }

        private static void open_def(StringBuilder sb, string className, DataBase db) {
            sb.Line("public:", true);
            sb.Line("int Open();");
            sb.Line();
            sb.Line("private:", true);
            sb.Line("int OpenDatabase();");
            sb.Line("int InitTables();");
            sb.Line("int PrepareQueryStatements();");
            sb.Line();
        }

        private static void open_impl(StringBuilder sb, string className, DataBase db) {
            var openImpl=@"
int $(className)::Open()
{
    int openResult = OpenDatabase();
    int ret = SQLITE_ERROR;
    if(openResult==SQLITE_OK)
    {
        if(InitTables()==SQLITE_OK)
        {
            ret = PrepareQueryStatements();
        }
        else
        {
            ret = SQLITE_ERROR;
        }
    }
    else
    {
        if(openResult==RESULT_ALREADY_EXISTS)
        {
            ret = SQLITE_OK;
        }
        else
        {
            ret = SQLITE_ERROR;
        }
    }
    return ret;
}    

int $(className)::OpenDatabase()
{
    bool exist = false;
    {
        exist = m_pSqlite!=NULL;
    }

    if(!exist)
    {
        int ret = sqlite3_open(m_dbPath.c_str(), &m_pSqlite);

        if (ret == SQLITE_OK)
        {
            m_openReferenceCount = 1;
            return SQLITE_OK;
        }
        else
        {
            printf($(')sqlite3_open File (% s) failed, result = % d)$('), m_dbPath.c_str(), ret);
            return SQLITE_ERROR;
        }
    }
    else
    {
        m_openReferenceCount++;
        return RESULT_ALREADY_EXISTS;
    }
}

int $(className)::InitTables()
{
    for (size_t i=0;i<sizeof(TaskCreateTableStatements)/sizeof(TaskCreateTableStatements[0]);i++)
    {
        SQLCreateTable s = TaskCreateTableStatements[i];
        int ret = sqlite3_exec(m_pSqlite, s.sql.c_str(), NULL, NULL, NULL);
        if(ret!=SQLITE_OK)
        {
            printf($(')create table (%s) (%s) failed, result = %d$('), m_dbPath.c_str(),s.id, ret);
            Close();
            return SQLITE_ERROR;
        }
    }
    return SQLITE_OK;
}

int $(className)::PrepareQueryStatements()
{
    for (size_t i = 0; i < sizeof(TaskQueryStatements)/sizeof(TaskQueryStatements[0]); i++)
    {
        const char* pszTail = NULL;
        int ret = sqlite3_prepare_v2(m_pSqlite, TaskQueryStatements[i].sql.c_str(), TaskQueryStatements[i].sql.length(), &m_sqls[i], &pszTail);
        if (ret != SQLITE_OK)
        {
            printf($(')sqlite3_prepare_v2 (%s), result = %d$('), TaskQueryStatements[i].sql.c_str(), ret);
            Close();
            return SQLITE_ERROR;
        }
    }
    printf($(')opend database (%s) ok$('), m_dbPath.c_str());

    return SQLITE_OK;
}
    ";

            sb.Line(openImpl.Replace("$(')", "\"").Replace("$(className)", className), true);

        }

        private static void transaction_def(StringBuilder sb, string className) {
            sb.Line("public:", true);
            sb.Line("int BeginTransaction();");
            sb.Line("int EndTransaction();");
            sb.Line("int Exec(const std::string& statement);");
            sb.Line();
        }

        private static void transaction_impl(StringBuilder sb, string className) {
            var impl=@"
int $(className)::BeginTransaction()
{
    char* errorInfo = NULL;
    int ret = sqlite3_exec(m_pSqlite, $(')BEGIN TRANSACTION$('), NULL, NULL, &errorInfo); 
    if(errorInfo!=NULL)
    {
        free(errorInfo);
    }
    if (ret == SQLITE_OK)
    {
        return SQLITE_OK;
    } 
    else 
    {
        return SQLITE_ERROR;
    }
}

int $(className)::EndTransaction() 
{
    char* errorInfo = NULL;
    int ret = sqlite3_exec(m_pSqlite, $(')COMMIT TRANSACTION$('), NULL, NULL, &errorInfo);
    if(errorInfo!=NULL)
    {
        free(errorInfo);
    }
    if (ret == SQLITE_OK) 
    {
        return SQLITE_OK;
    } 
    else 
    {
        return SQLITE_ERROR;
    }
}

int $(className)::Exec(const std::string& statement)
{
    char* errorInfo = NULL;
    int ret = sqlite3_exec(m_pSqlite, statement.c_str(), NULL, NULL, &errorInfo);
    if(errorInfo!=NULL)
    {
        free(errorInfo);
    }
    if (ret == SQLITE_OK) 
    {
        return SQLITE_OK;
    } 
    else 
    {
        return SQLITE_ERROR;
    }
}
";
            sb.Line(impl.Replace("$(')", "\"").Replace("$(className)", className), true);
        }

        private static void close_def(StringBuilder sb, string className, DataBase db) {
            sb.Line("public:", true);
            sb.Line("int Close();");
            sb.Line();
        }

        private static void close_impl(StringBuilder sb, string className, DataBase db) {
            var closeImpl=@"
int $(className)::Close()
{
    bool exist=false;
    {
        exist = m_pSqlite!=NULL;
    }
    if (exist)
    {
        m_openReferenceCount--;
        if (m_openReferenceCount == 0)
        {
            for (size_t i = 0; i < sizeof(m_sqls)/sizeof(m_sqls[0]); i++)
            {
                if (m_sqls[i] != NULL)
                {
                    sqlite3_finalize(m_sqls[i]);
                    m_sqls[i] = NULL;
                }
            }
            for (;;)
            {
                sqlite3_stmt* pStmt = sqlite3_next_stmt(m_pSqlite, NULL);
                if (pStmt == NULL)
                {
                    break;
                }
                sqlite3_finalize(pStmt);
            }
            sqlite3_close(m_pSqlite);
            m_pSqlite = NULL;
        }
        return SQLITE_OK;
    }
    else
    {
        return SQLITE_OK;
    }
}
";
            sb.Line(closeImpl.Replace("$(className)", className), true);
        }

        private static void insert_def(StringBuilder sb, string className, string tag, List<Field> fields) {
            tag="Insert"+tag;
            var declare=generate_ltype_declare(fields);
            sb.FormatLine("int {0}({1});", tag, declare);
        }

        private static void insert_impl(StringBuilder sb, string className, string tag, List<Field> fields) {
            tag="Insert"+tag;
            var declare=generate_ltype_declare(fields);
            sb.FormatLine("int {0}::{1}({2})", className, tag, declare);
            sb.Line("{").Push();

            sb.FormatLine("sqlite3_stmt* pStmt = m_sqls[SQL_{0}];", tag);
            sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"get stmt\", pStmt != NULL, SQLITE_ERROR);", tag);
            sb.Line();

            sb.Line("int ret = sqlite3_reset(pStmt);");
            sb.FormatLine("VERIFY_RET(\"{0}\", \"sqlite3_reset\", ret);", tag);
            sb.Line();

            bind(sb, tag, fields);

            sb.Line("ret = sqlite3_step(pStmt);");
            sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"step stmt\", ret == SQLITE_DONE, ret);", tag);
            sb.Line();
            sb.Line("return SQLITE_OK;");

            sb.Pop().Line("}");
            sb.Line();
        }

        private static void remove_def(StringBuilder sb, string className, string tag, List<Field> fields) {
            tag="Remove"+tag;
            var declare=generate_ltype_declare(fields.Where(f => f.primary));
            sb.FormatLine("int {0}({1});", tag, declare);

            var removeGroup=fields.SelectMany(f => f.remove_labels).Distinct();
            foreach (var removeLabel in removeGroup) {
                declare=generate_ltype_declare(fields.Where(f => f.remove_labels.Contains(removeLabel)));
                sb.FormatLine("int {0}({1});", tag, declare);
            }
        }

        private static void remove_impl(StringBuilder sb, string className, string tag, List<Field> fields) {
            tag="Remove"+tag;
            var declare=generate_ltype_declare(fields.Where(f => f.primary));
            sb.FormatLine("int {0}::{1}({2})", className, tag, declare);
            sb.Line("{").Push();

            sb.FormatLine("sqlite3_stmt* pStmt = m_sqls[SQL_{0}ByPrimaryKey];", tag);
            sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"get stmt\", pStmt != NULL, SQLITE_ERROR);", tag);
            sb.Line();

            sb.Line("int ret = sqlite3_reset(pStmt);");
            sb.FormatLine("VERIFY_RET(\"{0}\", \"sqlite3_reset\", ret);", tag);
            sb.Line();

            // Bind Primary Key
            bind(sb, tag, fields.Where(f => f.primary));

            sb.Line("ret = sqlite3_step(pStmt);");
            sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"step stmt\", ret == SQLITE_DONE, ret);", tag);
            sb.Line();
            sb.Line("return SQLITE_OK;");
            sb.Pop().Line("}");
            sb.Line();

            var removeGroup=fields.SelectMany(f => f.remove_labels).Distinct();
            foreach (var removeLabel in removeGroup) {
                declare=generate_ltype_declare(fields.Where(f => f.remove_labels.Contains(removeLabel)).ToList());
                sb.FormatLine("int {0}::{1}({2})", className, tag, declare);
                sb.Line("{").Push();

                sb.FormatLine("sqlite3_stmt* pStmt = m_sqls[SQL_{0}_{1}];", tag, removeLabel);
                sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"get stmt\", pStmt != NULL, SQLITE_ERROR);", tag);
                sb.Line();

                sb.Line("int ret = sqlite3_reset(pStmt);");
                sb.FormatLine("VERIFY_RET(\"{0}\", \"sqlite3_reset\", ret);", tag);
                sb.Line();

                // Bind 
                bind(sb, tag, fields.Where(f => f.remove_labels.Contains(removeLabel)));

                sb.Line("ret = sqlite3_step(pStmt);");
                sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"step stmt\", ret == SQLITE_DONE, ret);", tag);
                sb.Line();
                sb.Line("return SQLITE_OK;");
                sb.Pop().Line("}");
                sb.Line();
            }
        }

        private static void beginfind_def(StringBuilder sb, string className, string tag, List<Field> fields) {
            tag="Find"+tag;
            int index=0;
            var declare="";
            sb.FormatLine("int Begin{0}({1}sqlite3_stmt **ppStmt);", tag, declare);

            var searchKeys=fields.SelectMany(f => f.search_keys).Distinct();
            var searchValues=fields.SelectMany(f => f.search_keys).Distinct();

            foreach (var searchLabel in searchKeys) {
                declare=generate_ltype_declare(fields.Where(field => field.search_keys.Contains(searchLabel)));
                sb.FormatLine("int Begin{0}({1}, sqlite3_stmt** ppStmt);", tag, declare);
            }
        }

        private static void beginfind_impl(StringBuilder sb, string className, string tag, List<Field> fields) {
            var originTag=tag;
            var searchName=string.Format("FindAll{0}s", tag);
            tag="BeginFind"+tag;
            var declare="";

            sb.FormatLine("int {0}::{1}({2}sqlite3_stmt **ppStmt)", className, tag, declare);
            sb.Line("{").Push();
            sb.Line("*ppStmt = NULL;");
            sb.Line();
            sb.Line("int ret = SQLITE_OK;");
            sb.Line();
            sb.FormatLine("sqlite3_stmt* pStmt = m_sqls[SQL_{0}];", searchName);
            sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"get stmt\", pStmt != NULL, SQLITE_ERROR);", tag);
            sb.Line();
            sb.Line("ret = sqlite3_reset(pStmt);");
            sb.FormatLine("VERIFY_RET(\"{0}\", \"sqlite3_reset\", ret);", tag);
            sb.Line();

            sb.Line("*ppStmt = pStmt;");
            sb.Line();
            sb.Line("return SQLITE_OK;");
            sb.Pop().Line("}");
            sb.Line();

            var searchKeys=fields.SelectMany(f => f.search_keys).Distinct();
            foreach (var searchLabel in searchKeys) {
                declare=declare=generate_ltype_declare(fields.Where(field => field.search_keys.Contains(searchLabel)));
                sb.FormatLine("int {0}::{1}({2}, sqlite3_stmt** ppStmt)", className, tag, declare);
                sb.Line("{").Push();

                sb.Line("*ppStmt = NULL;");
                sb.Line();

                sb.Line("int ret = SQLITE_OK;");
                sb.Line();

                searchName=get_label_name("Find"+originTag, searchLabel.Replace("k", ""));
                sb.FormatLine("sqlite3_stmt* pStmt = m_sqls[SQL_{0}];", searchName);
                sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"get stmt\", pStmt != NULL, SQLITE_ERROR);", tag);
                sb.Line();

                sb.Line("ret = sqlite3_reset(pStmt);");
                sb.FormatLine("VERIFY_RET(\"{0}\", \"sqlite3_reset\", ret);", tag);
                sb.Line();

                bind(sb, tag, fields.Where(field => field.search_keys.Contains(searchLabel)));

                sb.Line("*ppStmt = pStmt;");
                sb.Line();
                sb.Line("return SQLITE_OK;");
                sb.Pop().Line("}");
                sb.Line();
            }
        }

        private static void movenext_def(StringBuilder sb, string className, string tag, List<Field> fields) {
            tag="MoveNext"+tag;
            var declare=generate_rtype_declare(fields);
            sb.FormatLine("int {0}(sqlite3_stmt* pStmt, {1});", tag, declare);

            var searchValues=fields.SelectMany(f => f.search_values).Distinct();
            foreach (var searchLabel in searchValues) {
                declare=generate_rtype_declare(fields.Where(field => field.search_values.Contains(searchLabel)));
                sb.FormatLine("int {0}(sqlite3_stmt* pStmt, {1});", tag, declare);
            }
        }

        private static void movenext_impl(StringBuilder sb, string className, string tag, List<Field> fields) {
            tag="MoveNext"+tag;
            var declare=generate_rtype_declare(fields);
            sb.FormatLine("int {0}::{1}(sqlite3_stmt* pStmt, {2})", className, tag, declare);
            sb.PushLine("{");

            sb.Line("int ret = sqlite3_step(pStmt);");
            sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"step stmt\", ret == SQLITE_ROW, ret);", tag);
            sb.Line();

            column(sb, tag, fields);

            sb.Line("return SQLITE_OK;");
            sb.PopLine("}");
            sb.Line();

            var searchValues=fields.SelectMany(f => f.search_values).Distinct();
            foreach (var searchLabel in searchValues) {
                var valueFields=fields.Where(field => field.search_values.Contains(searchLabel));

                declare=generate_rtype_declare(valueFields);
                sb.FormatLine("int {0}::{1}(sqlite3_stmt* pStmt, {2})", className, tag, declare);
                sb.PushLine("{");

                sb.Line("int ret = sqlite3_step(pStmt);");
                sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"step stmt\", ret == SQLITE_ROW, ret);", tag);
                sb.Line();

                column(sb, tag, valueFields);

                sb.Line("return SQLITE_OK;");
                sb.PopLine("}");
                sb.Line();
            }
        }

        private static void endfind_def(StringBuilder sb, string className, string tag, List<Field> fields) {
            sb.FormatLine("int EndFind{0}(sqlite3_stmt * pStmt);", tag);
        }

        private static void endfind_impl(StringBuilder sb, string className, string tag, List<Field> fields) {
            tag="EndFind"+tag;
            sb.FormatLine("int {0}::{1}(sqlite3_stmt * pStmt)", className, tag);
            sb.Line("{").Push();
            sb.Line("//DO Nothing");
            sb.Line("return SQLITE_OK;");
            sb.Pop().Line("}");
            sb.Line();
        }

        private static void find_by_primarykey_def(StringBuilder sb, string className, string tag, List<Field> fields) {
            tag="Find"+tag;
            var declare=generate_declare(fields, f => f.primary, f => !f.primary);
            sb.FormatLine("int {0}({1});", tag, declare);
        }

        private static void find_by_primarykey_impl(StringBuilder sb, string className, string tag, List<Field> fields) {
            tag="Find"+tag;
            var declare=generate_declare(fields, f => f.primary, f => !f.primary);
            sb.FormatLine("int {0}::{1}({2})", className, tag, declare);
            sb.PushLine("{");

            sb.Line("int ret = SQLITE_OK;");
            sb.Line();

            sb.FormatLine("sqlite3_stmt* pStmt = m_sqls[SQL_{0}ByPrimaryKey];", tag);
            sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"get stmt\", pStmt != NULL, SQLITE_ERROR);", tag);
            sb.Line();

            sb.Line("ret = sqlite3_reset(pStmt);");
            sb.FormatLine("VERIFY_RET(\"{0}\", \"sqlite3_reset\", ret);", tag);
            sb.Line();

            bind(sb, tag, fields.Where(f => f.primary));

            sb.Line("ret = sqlite3_step(pStmt);");
            sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"step stmt\", ret == SQLITE_ROW, ret);", tag);
            sb.Line();

            column(sb, tag, fields.Where(f => !f.primary));

            sb.Line("return SQLITE_OK;");
            sb.PopLine("}");

            sb.Line();
        }

        private static void update_def(StringBuilder sb, string className, string tag, List<Field> fields) {
            var updateKeys=fields.SelectMany(f => f.update_keys).Distinct();
            foreach (var updateKey in updateKeys) {
                var updateValue=updateKey.Replace("k", "v");
                var declare=generate_ltype_declare(fields.Where(f => f.update_keys.Contains(updateKey)||f.update_values.Contains(updateValue)));
                sb.FormatLine("int Update{0}({1});", tag, declare);
            }
        }

        private static void update_impl(StringBuilder sb, string className, string tag, List<Field> fields) {
            var updateKeys=fields.SelectMany(f => f.update_keys).Distinct();
            foreach (var updateKey in updateKeys) {
                var updateValue=updateKey.Replace("k", "v");

                tag="Update"+tag;
                var declare=generate_ltype_declare(fields.Where(f => f.update_keys.Contains(updateKey)||f.update_values.Contains(updateValue)));
                sb.FormatLine("int {0}::{1}({2})", className, tag, declare);

                sb.Line("{").Push();

                var updateName=get_label_name(tag, updateKey.Replace("k", ""));
                sb.FormatLine("sqlite3_stmt* pStmt = m_sqls[SQL_{0}];", updateName);
                sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"get stmt\", pStmt != NULL, SQLITE_ERROR);", tag);
                sb.Line();

                sb.Line("int ret = sqlite3_reset(pStmt);");
                sb.FormatLine("VERIFY_RET(\"{0}\", \"sqlite3_reset\", ret);", tag);
                sb.Line();

                // Bind Key and Value
                bind(sb, tag, fields.Where(f => f.update_keys.Contains(updateKey)||f.update_values.Contains(updateValue)));

                sb.Line("ret = sqlite3_step(pStmt);");
                sb.FormatLine("VERIFY_RET_BY(\"{0}\", \"step stmt\", ret == SQLITE_DONE, ret);", tag);
                sb.Line();
                sb.Line("return SQLITE_OK;");
                sb.Pop().Line("}");
                sb.Line();
            }
        }

        private static void bind(StringBuilder sb, string tag, IEnumerable<Field> fields) {
            var index=0;
            foreach (var field in fields) {
                index++;
                bind(sb, tag, field.type, index, clname(field.name));
            }
        }

        private static void column(StringBuilder sb, string tag, IEnumerable<Field> fields) {
            var index=0;
            foreach (var field in fields) {
                column(sb, tag, field.type, index, crname(field.name));
                index++;
            }
        }

        private static void bind(StringBuilder sb, string tag, string type, int index, string field) {
            switch (type) {
                case "bytes":
                    bind_text(sb, tag, index, field);
                    break;
                case "i64":
                    bind_int64(sb, tag, index, field);
                    break;
                case "i32":
                    bind_int32(sb, tag, index, field);
                    break;
                default:
                    break;
            }
        }

        private static void bind_text(StringBuilder sb, string tag, int index, string field) {
            sb.FormatLine("ret = sqlite3_bind_text(pStmt, {0}, {1}.c_str(), {1}.length(), SQLITE_TRANSIENT);", index, field);
            sb.FormatLine("VERIFY_RET(\"{0}\", \"bind {1}\", ret);", tag, field);
            sb.Line();
        }

        private static void bind_int32(StringBuilder sb, string tag, int index, string field) {
            sb.FormatLine("ret = sqlite3_bind_int(pStmt, {0}, {1});", index, field);
            sb.FormatLine("VERIFY_RET(\"{0}\", \"bind {1}\", ret);", tag, field);
            sb.Line();
        }

        private static void bind_int64(StringBuilder sb, string tag, int index, string field) {
            sb.FormatLine("ret = sqlite3_bind_int64(pStmt, {0}, {1});", index, field);
            sb.FormatLine("VERIFY_RET(\"{0}\", \"bind {1}\", ret);", tag, field);
            sb.Line();
        }

        private static void column(StringBuilder sb, string tag, string type, int index, string field) {
            switch (type) {
                case "bytes":
                    column_text(sb, tag, index, field);
                    break;
                case "i64":
                    column_int64(sb, tag, index, field);
                    break;
                case "i32":
                    column_int32(sb, tag, index, field);
                    break;
                default:
                    break;
            }
        }

        private static void column_text(StringBuilder sb, string tag, int index, string field) {
            sb.FormatLine("const char* {1}_buffer = (const char*)(sqlite3_column_text(pStmt, {0}));", index, field);
            sb.Line(string.Format("if ({0}_buffer != NULL) {{", field)).Push();
            sb.FormatLine("{0}.assign({0}_buffer, strlen({0}_buffer));", field);
            sb.Pop().Line("}");
            sb.Line();
        }

        private static void column_int32(StringBuilder sb, string tag, int index, string field) {
            sb.FormatLine("{1} = sqlite3_column_int(pStmt, {0});", index, field);
            sb.Line();
        }

        private static void column_int64(StringBuilder sb, string tag, int index, string field) {
            sb.FormatLine("{1} = sqlite3_column_int64(pStmt, {0});", index, field);
            sb.Line();
        }

        private static string cltype(string type) {
            switch (type) {
                case "bytes":
                    return "const std::string&";
                case "i64":
                    return "const int64_t&";
                case "i32":
                    return "const int32_t&";
                default:
                    throw new ArgumentException("not supoort field type");
            }
        }

        private static string crtype(string type) {
            switch (type) {
                case "bytes":
                    return "std::string&";
                case "i64":
                    return "int64_t&";
                case "i32":
                    return "int32_t&";
                default:
                    throw new ArgumentException("not supoort field type");
            }
        }

        private static string ctype(string type) {
            switch (type) {
                case "bytes":
                    return "std::string";
                case "i64":
                    return "int64_t";
                case "i32":
                    return "int32_t";
                default:
                    throw new ArgumentException("not supoort field type");
            }
        }

        private static string clname(string name) {
            return name+"_in";
        }

        private static string crname(string name) {
            return name+"_out";
        }

        private static string generate_declare(IEnumerable<Field> fields, Func<Field, bool> lfilter, Func<Field, bool> rfilter) {
            var sb=new StringBuilder();
            int i=0;
            foreach (var field in fields) {
                string type="";
                string variable="";
                if (lfilter(field)) {
                    type=cltype(field.type);
                    variable=clname(field.name);
                    if (i==0) {
                        sb.AppendFormat("{0} {1}", type, variable);
                    } else {
                        sb.AppendFormat(", {0} {1}", type, variable);
                    }
                    i++;
                }
            }
            foreach (var field in fields) {
                string type="";
                string variable="";
                if (rfilter(field)) {
                    type=crtype(field.type);
                    variable=crname(field.name);
                    if (i==0) {
                        sb.AppendFormat("{0} {1}", type, variable);
                    } else {
                        sb.AppendFormat(", {0} {1}", type, variable);
                    }
                    i++;
                }
            }

            return sb.ToString();
        }

        private static string generate_ltype_declare(IEnumerable<Field> fields) {
            var sb=new StringBuilder();
            int i=0;
            foreach (var field in fields) {
                var type=cltype(field.type);
                var variable=clname(field.name);
                if (i==0) {
                    sb.AppendFormat("{0} {1}", type, variable);
                } else {
                    sb.AppendFormat(", {0} {1}", type, variable);
                }
                i++;
            }
            return sb.ToString();
        }

        private static string generate_rtype_declare(IEnumerable<Field> fields) {
            var sb=new StringBuilder();
            int i=0;
            foreach (var field in fields) {
                var type=crtype(field.type);
                var variable=crname(field.name);
                if (i==0) {
                    sb.AppendFormat("{0} {1}", type, variable);
                } else {
                    sb.AppendFormat(", {0} {1}", type, variable);
                }
                i++;
            }
            return sb.ToString();
        }

        private static string sqlitetype(string type) {
            switch (type) {
                case "bytes":
                    return "NVARCHAR";
                case "i64":
                    return "BIGINT";
                case "i32":
                    return "INT";
                default:
                    throw new ArgumentException("not supoort field type");
            }
        }

        private static string sql_create(string tag, List<Field> fields) {
            var sql="";
            int primaryKeyCount=fields.Count(f => f.primary);
            int index=0;
            foreach (var field in fields) {
                if (index>0) {
                    sql+=",";
                }
                sql+=" "+field.name+" "+sqlitetype(field.type);

                if (field.primary&&primaryKeyCount==1) {
                    sql+=" PRIMARY KEY";
                }
                index++;
            }
            if (primaryKeyCount>1) {
                sql+=", PRIMARY KEY(";
                index=0;
                foreach (var field in fields.Where(f => f.primary)) {
                    if (index>0) {
                        sql+=",";
                    }
                    sql+=" "+field.name;
                    index++;
                }
                sql+=") ";
            }


            if (tag=="Piece"||tag=="FountainFile"||tag=="Chunk") {
                sql+=", FOREIGN KEY(file_id) REFERENCES File(file_id)";
            }

            if (tag=="Piece"||tag=="Chunk") {
                sql+=", FOREIGN KEY(chunk_id) REFERENCES FountainFile(chunk_id)";
            }


            return string.Format("TABLE(\"{0} ({1})\")", tag, sql);
        }

        private static string sql_insert(string tag, List<Field> fields) {
            var sql="";
            var args="";
            int index=0;
            foreach (var field in fields) {
                if (index>0) {
                    sql+=", ";
                    args+=",";
                }
                sql+=field.name;
                args+="?"+(index+1);

                index++;
            }
            return string.Format("INSERT INTO {0} ({1}) VALUES ({2})", tag, sql, args);
        }

        private static string sql_find_by_primarykey(string tag, List<Field> fields) {
            var sql="";
            var args="";
            int index=0;
            int argIndex=0;
            foreach (var field in fields) {
                if (!field.primary) {
                    if (index>0) {
                        sql+=", ";
                    }
                    sql+=field.name;
                    index++;
                } else {
                    if (argIndex>0) {
                        args+=" AND ";
                    }
                    args+=field.name+"=?"+(argIndex+1);
                    argIndex++;
                }
            }
            return string.Format("SELECT {0} FROM {1} WHERE {2}", sql, tag, args);
        }

        private static string sql_find_by_all(string tag, List<Field> fields) {
            var sql="";
            int index=0;
            foreach (var field in fields) {
                if (index>0) {
                    sql+=", ";
                }
                sql+=field.name;
                index++;
            }
            return string.Format("SELECT {0} FROM {1}", sql, tag);
        }

        private static string sql_find_by_ky(string tag, List<Field> fields, string label) {
            var sql="";
            var args="";
            int index=0;
            int argIndex=0;
            foreach (var field in fields) {
                if (field.search_values.Contains(label.Replace("k", "v"))) {
                    if (index>0) {
                        sql+=", ";
                    }
                    sql+=field.name;
                    index++;
                } else if (field.search_keys.Contains(label)) {
                    if (argIndex>0) {
                        args+=" AND ";
                    }
                    args+=field.name+"=?"+(argIndex+1);
                    argIndex++;
                }
            }
            return string.Format("SELECT {0} FROM {1} WHERE {2}", sql, tag, args);
        }

        private static string sql_update_by_key(string tag, List<Field> fields, string keyLabel) {
            var value="";
            var args="";
            int valueIndex=0;
            int argIndex=0;
            int index=0;
            var valueLabel=keyLabel.Replace("k", "v");

            foreach (var field in fields) {
                if (field.update_keys.Contains(keyLabel)) {
                    if (argIndex>0) {
                        args+=" AND ";
                    }
                    args+=field.name+"=?"+(index+1);
                    argIndex++;
                    index++;
                }
            }

            foreach (var field in fields) {
                if (field.update_values.Contains(valueLabel)) {
                    if (valueIndex>0) {
                        value+=", ";
                    }
                    value+=field.name+"=?"+(index+1);
                    valueIndex++;
                    index++;
                }
            }

            return string.Format("UPDATE {0} SET {1} WHERE {2}", tag, value, args);
        }

        private static string sql_remove_by_primarykey(string tag, List<Field> fields) {
            var args="";
            int index=0;
            foreach (var field in fields.Where(f => f.primary)) {
                if (index>0) {
                    args+=" AND ";
                }
                args+=field.name+"=?"+(index+1);

                index++;
            }
            return string.Format("DELETE FROM {0} WHERE {1}", tag, args);
        }

        private static string sql_remove_by_label(string tag, List<Field> fields, string label) {
            var args="";
            int index=0;
            foreach (var field in fields.Where(f => f.remove_labels.Contains(label))) {
                if (index>0) {
                    args+=" AND ";
                }
                args+=field.name+"=?"+(index+1);

                index++;
            }
            return string.Format("DELETE FROM {0} WHERE {1}", tag, args);
        }
    }
}
